// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "RoomXML.hpp"

namespace rxml
{
  // RoomXML
  // 

  const RoomXML::name_type& RoomXML::
  name () const
  {
    return this->name_.get ();
  }

  RoomXML::name_type& RoomXML::
  name ()
  {
    return this->name_.get ();
  }

  void RoomXML::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void RoomXML::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const RoomXML::scenery_type& RoomXML::
  scenery () const
  {
    return this->scenery_.get ();
  }

  RoomXML::scenery_type& RoomXML::
  scenery ()
  {
    return this->scenery_.get ();
  }

  void RoomXML::
  scenery (const scenery_type& x)
  {
    this->scenery_.set (x);
  }

  void RoomXML::
  scenery (::std::auto_ptr< scenery_type > x)
  {
    this->scenery_.set (x);
  }

  const RoomXML::xTiles_type& RoomXML::
  xTiles () const
  {
    return this->xTiles_.get ();
  }

  RoomXML::xTiles_type& RoomXML::
  xTiles ()
  {
    return this->xTiles_.get ();
  }

  void RoomXML::
  xTiles (const xTiles_type& x)
  {
    this->xTiles_.set (x);
  }

  const RoomXML::yTiles_type& RoomXML::
  yTiles () const
  {
    return this->yTiles_.get ();
  }

  RoomXML::yTiles_type& RoomXML::
  yTiles ()
  {
    return this->yTiles_.get ();
  }

  void RoomXML::
  yTiles (const yTiles_type& x)
  {
    this->yTiles_.set (x);
  }

  const RoomXML::width_type& RoomXML::
  width () const
  {
    return this->width_.get ();
  }

  RoomXML::width_type& RoomXML::
  width ()
  {
    return this->width_.get ();
  }

  void RoomXML::
  width (const width_type& x)
  {
    this->width_.set (x);
  }

  const RoomXML::floorType_type& RoomXML::
  floorType () const
  {
    return this->floorType_.get ();
  }

  RoomXML::floorType_type& RoomXML::
  floorType ()
  {
    return this->floorType_.get ();
  }

  void RoomXML::
  floorType (const floorType_type& x)
  {
    this->floorType_.set (x);
  }

  void RoomXML::
  floorType (::std::auto_ptr< floorType_type > x)
  {
    this->floorType_.set (x);
  }

  const RoomXML::deltaX_optional& RoomXML::
  deltaX () const
  {
    return this->deltaX_;
  }

  RoomXML::deltaX_optional& RoomXML::
  deltaX ()
  {
    return this->deltaX_;
  }

  void RoomXML::
  deltaX (const deltaX_type& x)
  {
    this->deltaX_.set (x);
  }

  void RoomXML::
  deltaX (const deltaX_optional& x)
  {
    this->deltaX_ = x;
  }

  const RoomXML::deltaY_optional& RoomXML::
  deltaY () const
  {
    return this->deltaY_;
  }

  RoomXML::deltaY_optional& RoomXML::
  deltaY ()
  {
    return this->deltaY_;
  }

  void RoomXML::
  deltaY (const deltaY_type& x)
  {
    this->deltaY_.set (x);
  }

  void RoomXML::
  deltaY (const deltaY_optional& x)
  {
    this->deltaY_ = x;
  }

  const RoomXML::triple_room_data_optional& RoomXML::
  triple_room_data () const
  {
    return this->triple_room_data_;
  }

  RoomXML::triple_room_data_optional& RoomXML::
  triple_room_data ()
  {
    return this->triple_room_data_;
  }

  void RoomXML::
  triple_room_data (const triple_room_data_type& x)
  {
    this->triple_room_data_.set (x);
  }

  void RoomXML::
  triple_room_data (const triple_room_data_optional& x)
  {
    this->triple_room_data_ = x;
  }

  void RoomXML::
  triple_room_data (::std::auto_ptr< triple_room_data_type > x)
  {
    this->triple_room_data_.set (x);
  }

  const RoomXML::floor_type& RoomXML::
  floor () const
  {
    return this->floor_.get ();
  }

  RoomXML::floor_type& RoomXML::
  floor ()
  {
    return this->floor_.get ();
  }

  void RoomXML::
  floor (const floor_type& x)
  {
    this->floor_.set (x);
  }

  void RoomXML::
  floor (::std::auto_ptr< floor_type > x)
  {
    this->floor_.set (x);
  }

  const RoomXML::walls_optional& RoomXML::
  walls () const
  {
    return this->walls_;
  }

  RoomXML::walls_optional& RoomXML::
  walls ()
  {
    return this->walls_;
  }

  void RoomXML::
  walls (const walls_type& x)
  {
    this->walls_.set (x);
  }

  void RoomXML::
  walls (const walls_optional& x)
  {
    this->walls_ = x;
  }

  void RoomXML::
  walls (::std::auto_ptr< walls_type > x)
  {
    this->walls_.set (x);
  }

  const RoomXML::items_type& RoomXML::
  items () const
  {
    return this->items_.get ();
  }

  RoomXML::items_type& RoomXML::
  items ()
  {
    return this->items_.get ();
  }

  void RoomXML::
  items (const items_type& x)
  {
    this->items_.set (x);
  }

  void RoomXML::
  items (::std::auto_ptr< items_type > x)
  {
    this->items_.set (x);
  }


  // floorType
  // 

  floorType::
  floorType (value v)
  : ::xml_schema::string (_xsd_floorType_literals_[v])
  {
  }

  floorType::
  floorType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  floorType::
  floorType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  floorType::
  floorType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  floorType::
  floorType (const floorType& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  floorType& floorType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_floorType_literals_[v]);

    return *this;
  }


  // triple_room_data
  // 

  const triple_room_data::northeast_optional& triple_room_data::
  northeast () const
  {
    return this->northeast_;
  }

  triple_room_data::northeast_optional& triple_room_data::
  northeast ()
  {
    return this->northeast_;
  }

  void triple_room_data::
  northeast (const northeast_type& x)
  {
    this->northeast_.set (x);
  }

  void triple_room_data::
  northeast (const northeast_optional& x)
  {
    this->northeast_ = x;
  }

  void triple_room_data::
  northeast (::std::auto_ptr< northeast_type > x)
  {
    this->northeast_.set (x);
  }

  const triple_room_data::southeast_optional& triple_room_data::
  southeast () const
  {
    return this->southeast_;
  }

  triple_room_data::southeast_optional& triple_room_data::
  southeast ()
  {
    return this->southeast_;
  }

  void triple_room_data::
  southeast (const southeast_type& x)
  {
    this->southeast_.set (x);
  }

  void triple_room_data::
  southeast (const southeast_optional& x)
  {
    this->southeast_ = x;
  }

  void triple_room_data::
  southeast (::std::auto_ptr< southeast_type > x)
  {
    this->southeast_.set (x);
  }

  const triple_room_data::northwest_optional& triple_room_data::
  northwest () const
  {
    return this->northwest_;
  }

  triple_room_data::northwest_optional& triple_room_data::
  northwest ()
  {
    return this->northwest_;
  }

  void triple_room_data::
  northwest (const northwest_type& x)
  {
    this->northwest_.set (x);
  }

  void triple_room_data::
  northwest (const northwest_optional& x)
  {
    this->northwest_ = x;
  }

  void triple_room_data::
  northwest (::std::auto_ptr< northwest_type > x)
  {
    this->northwest_.set (x);
  }

  const triple_room_data::southwest_optional& triple_room_data::
  southwest () const
  {
    return this->southwest_;
  }

  triple_room_data::southwest_optional& triple_room_data::
  southwest ()
  {
    return this->southwest_;
  }

  void triple_room_data::
  southwest (const southwest_type& x)
  {
    this->southwest_.set (x);
  }

  void triple_room_data::
  southwest (const southwest_optional& x)
  {
    this->southwest_ = x;
  }

  void triple_room_data::
  southwest (::std::auto_ptr< southwest_type > x)
  {
    this->southwest_.set (x);
  }

  const triple_room_data::eastnorth_optional& triple_room_data::
  eastnorth () const
  {
    return this->eastnorth_;
  }

  triple_room_data::eastnorth_optional& triple_room_data::
  eastnorth ()
  {
    return this->eastnorth_;
  }

  void triple_room_data::
  eastnorth (const eastnorth_type& x)
  {
    this->eastnorth_.set (x);
  }

  void triple_room_data::
  eastnorth (const eastnorth_optional& x)
  {
    this->eastnorth_ = x;
  }

  void triple_room_data::
  eastnorth (::std::auto_ptr< eastnorth_type > x)
  {
    this->eastnorth_.set (x);
  }

  const triple_room_data::eastsouth_optional& triple_room_data::
  eastsouth () const
  {
    return this->eastsouth_;
  }

  triple_room_data::eastsouth_optional& triple_room_data::
  eastsouth ()
  {
    return this->eastsouth_;
  }

  void triple_room_data::
  eastsouth (const eastsouth_type& x)
  {
    this->eastsouth_.set (x);
  }

  void triple_room_data::
  eastsouth (const eastsouth_optional& x)
  {
    this->eastsouth_ = x;
  }

  void triple_room_data::
  eastsouth (::std::auto_ptr< eastsouth_type > x)
  {
    this->eastsouth_.set (x);
  }

  const triple_room_data::westnorth_optional& triple_room_data::
  westnorth () const
  {
    return this->westnorth_;
  }

  triple_room_data::westnorth_optional& triple_room_data::
  westnorth ()
  {
    return this->westnorth_;
  }

  void triple_room_data::
  westnorth (const westnorth_type& x)
  {
    this->westnorth_.set (x);
  }

  void triple_room_data::
  westnorth (const westnorth_optional& x)
  {
    this->westnorth_ = x;
  }

  void triple_room_data::
  westnorth (::std::auto_ptr< westnorth_type > x)
  {
    this->westnorth_.set (x);
  }

  const triple_room_data::westsouth_optional& triple_room_data::
  westsouth () const
  {
    return this->westsouth_;
  }

  triple_room_data::westsouth_optional& triple_room_data::
  westsouth ()
  {
    return this->westsouth_;
  }

  void triple_room_data::
  westsouth (const westsouth_type& x)
  {
    this->westsouth_.set (x);
  }

  void triple_room_data::
  westsouth (const westsouth_optional& x)
  {
    this->westsouth_ = x;
  }

  void triple_room_data::
  westsouth (::std::auto_ptr< westsouth_type > x)
  {
    this->westsouth_.set (x);
  }

  const triple_room_data::bound_x_type& triple_room_data::
  bound_x () const
  {
    return this->bound_x_.get ();
  }

  triple_room_data::bound_x_type& triple_room_data::
  bound_x ()
  {
    return this->bound_x_.get ();
  }

  void triple_room_data::
  bound_x (const bound_x_type& x)
  {
    this->bound_x_.set (x);
  }

  void triple_room_data::
  bound_x (::std::auto_ptr< bound_x_type > x)
  {
    this->bound_x_.set (x);
  }

  const triple_room_data::bound_y_type& triple_room_data::
  bound_y () const
  {
    return this->bound_y_.get ();
  }

  triple_room_data::bound_y_type& triple_room_data::
  bound_y ()
  {
    return this->bound_y_.get ();
  }

  void triple_room_data::
  bound_y (const bound_y_type& x)
  {
    this->bound_y_.set (x);
  }

  void triple_room_data::
  bound_y (::std::auto_ptr< bound_y_type > x)
  {
    this->bound_y_.set (x);
  }


  // floor
  // 

  const floor::tile_sequence& floor::
  tile () const
  {
    return this->tile_;
  }

  floor::tile_sequence& floor::
  tile ()
  {
    return this->tile_;
  }

  void floor::
  tile (const tile_sequence& s)
  {
    this->tile_ = s;
  }


  // walls
  // 

  const walls::wall_sequence& walls::
  wall () const
  {
    return this->wall_;
  }

  walls::wall_sequence& walls::
  wall ()
  {
    return this->wall_;
  }

  void walls::
  wall (const wall_sequence& s)
  {
    this->wall_ = s;
  }


  // items
  // 

  const items::item_sequence& items::
  item () const
  {
    return this->item_;
  }

  items::item_sequence& items::
  item ()
  {
    return this->item_;
  }

  void items::
  item (const item_sequence& s)
  {
    this->item_ = s;
  }


  // northeast
  // 

  const northeast::x_type& northeast::
  x () const
  {
    return this->x_.get ();
  }

  northeast::x_type& northeast::
  x ()
  {
    return this->x_.get ();
  }

  void northeast::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const northeast::y_type& northeast::
  y () const
  {
    return this->y_.get ();
  }

  northeast::y_type& northeast::
  y ()
  {
    return this->y_.get ();
  }

  void northeast::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // southeast
  // 

  const southeast::x_type& southeast::
  x () const
  {
    return this->x_.get ();
  }

  southeast::x_type& southeast::
  x ()
  {
    return this->x_.get ();
  }

  void southeast::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const southeast::y_type& southeast::
  y () const
  {
    return this->y_.get ();
  }

  southeast::y_type& southeast::
  y ()
  {
    return this->y_.get ();
  }

  void southeast::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // northwest
  // 

  const northwest::x_type& northwest::
  x () const
  {
    return this->x_.get ();
  }

  northwest::x_type& northwest::
  x ()
  {
    return this->x_.get ();
  }

  void northwest::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const northwest::y_type& northwest::
  y () const
  {
    return this->y_.get ();
  }

  northwest::y_type& northwest::
  y ()
  {
    return this->y_.get ();
  }

  void northwest::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // southwest
  // 

  const southwest::x_type& southwest::
  x () const
  {
    return this->x_.get ();
  }

  southwest::x_type& southwest::
  x ()
  {
    return this->x_.get ();
  }

  void southwest::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const southwest::y_type& southwest::
  y () const
  {
    return this->y_.get ();
  }

  southwest::y_type& southwest::
  y ()
  {
    return this->y_.get ();
  }

  void southwest::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // eastnorth
  // 

  const eastnorth::x_type& eastnorth::
  x () const
  {
    return this->x_.get ();
  }

  eastnorth::x_type& eastnorth::
  x ()
  {
    return this->x_.get ();
  }

  void eastnorth::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const eastnorth::y_type& eastnorth::
  y () const
  {
    return this->y_.get ();
  }

  eastnorth::y_type& eastnorth::
  y ()
  {
    return this->y_.get ();
  }

  void eastnorth::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // eastsouth
  // 

  const eastsouth::x_type& eastsouth::
  x () const
  {
    return this->x_.get ();
  }

  eastsouth::x_type& eastsouth::
  x ()
  {
    return this->x_.get ();
  }

  void eastsouth::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const eastsouth::y_type& eastsouth::
  y () const
  {
    return this->y_.get ();
  }

  eastsouth::y_type& eastsouth::
  y ()
  {
    return this->y_.get ();
  }

  void eastsouth::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // westnorth
  // 

  const westnorth::x_type& westnorth::
  x () const
  {
    return this->x_.get ();
  }

  westnorth::x_type& westnorth::
  x ()
  {
    return this->x_.get ();
  }

  void westnorth::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const westnorth::y_type& westnorth::
  y () const
  {
    return this->y_.get ();
  }

  westnorth::y_type& westnorth::
  y ()
  {
    return this->y_.get ();
  }

  void westnorth::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // westsouth
  // 

  const westsouth::x_type& westsouth::
  x () const
  {
    return this->x_.get ();
  }

  westsouth::x_type& westsouth::
  x ()
  {
    return this->x_.get ();
  }

  void westsouth::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const westsouth::y_type& westsouth::
  y () const
  {
    return this->y_.get ();
  }

  westsouth::y_type& westsouth::
  y ()
  {
    return this->y_.get ();
  }

  void westsouth::
  y (const y_type& x)
  {
    this->y_.set (x);
  }


  // bound_x
  // 

  const bound_x::minimum_type& bound_x::
  minimum () const
  {
    return this->minimum_.get ();
  }

  bound_x::minimum_type& bound_x::
  minimum ()
  {
    return this->minimum_.get ();
  }

  void bound_x::
  minimum (const minimum_type& x)
  {
    this->minimum_.set (x);
  }

  const bound_x::maximum_type& bound_x::
  maximum () const
  {
    return this->maximum_.get ();
  }

  bound_x::maximum_type& bound_x::
  maximum ()
  {
    return this->maximum_.get ();
  }

  void bound_x::
  maximum (const maximum_type& x)
  {
    this->maximum_.set (x);
  }


  // bound_y
  // 

  const bound_y::minimum_type& bound_y::
  minimum () const
  {
    return this->minimum_.get ();
  }

  bound_y::minimum_type& bound_y::
  minimum ()
  {
    return this->minimum_.get ();
  }

  void bound_y::
  minimum (const minimum_type& x)
  {
    this->minimum_.set (x);
  }

  const bound_y::maximum_type& bound_y::
  maximum () const
  {
    return this->maximum_.get ();
  }

  bound_y::maximum_type& bound_y::
  maximum ()
  {
    return this->maximum_.get ();
  }

  void bound_y::
  maximum (const maximum_type& x)
  {
    this->maximum_.set (x);
  }


  // tile
  // 

  const tile::x_type& tile::
  x () const
  {
    return this->x_.get ();
  }

  tile::x_type& tile::
  x ()
  {
    return this->x_.get ();
  }

  void tile::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const tile::y_type& tile::
  y () const
  {
    return this->y_.get ();
  }

  tile::y_type& tile::
  y ()
  {
    return this->y_.get ();
  }

  void tile::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const tile::offsetX_type& tile::
  offsetX () const
  {
    return this->offsetX_.get ();
  }

  tile::offsetX_type& tile::
  offsetX ()
  {
    return this->offsetX_.get ();
  }

  void tile::
  offsetX (const offsetX_type& x)
  {
    this->offsetX_.set (x);
  }

  const tile::offsetY_type& tile::
  offsetY () const
  {
    return this->offsetY_.get ();
  }

  tile::offsetY_type& tile::
  offsetY ()
  {
    return this->offsetY_.get ();
  }

  void tile::
  offsetY (const offsetY_type& x)
  {
    this->offsetY_.set (x);
  }

  const tile::bitmap_type& tile::
  bitmap () const
  {
    return this->bitmap_.get ();
  }

  tile::bitmap_type& tile::
  bitmap ()
  {
    return this->bitmap_.get ();
  }

  void tile::
  bitmap (const bitmap_type& x)
  {
    this->bitmap_.set (x);
  }

  void tile::
  bitmap (::std::auto_ptr< bitmap_type > x)
  {
    this->bitmap_.set (x);
  }


  // wall
  // 

  const wall::axis_type& wall::
  axis () const
  {
    return this->axis_.get ();
  }

  wall::axis_type& wall::
  axis ()
  {
    return this->axis_.get ();
  }

  void wall::
  axis (const axis_type& x)
  {
    this->axis_.set (x);
  }

  void wall::
  axis (::std::auto_ptr< axis_type > x)
  {
    this->axis_.set (x);
  }

  const wall::index_type& wall::
  index () const
  {
    return this->index_.get ();
  }

  wall::index_type& wall::
  index ()
  {
    return this->index_.get ();
  }

  void wall::
  index (const index_type& x)
  {
    this->index_.set (x);
  }

  const wall::bitmap_type& wall::
  bitmap () const
  {
    return this->bitmap_.get ();
  }

  wall::bitmap_type& wall::
  bitmap ()
  {
    return this->bitmap_.get ();
  }

  void wall::
  bitmap (const bitmap_type& x)
  {
    this->bitmap_.set (x);
  }

  void wall::
  bitmap (::std::auto_ptr< bitmap_type > x)
  {
    this->bitmap_.set (x);
  }


  // item
  // 

  const item::label_type& item::
  label () const
  {
    return this->label_.get ();
  }

  item::label_type& item::
  label ()
  {
    return this->label_.get ();
  }

  void item::
  label (const label_type& x)
  {
    this->label_.set (x);
  }

  const item::direction_type& item::
  direction () const
  {
    return this->direction_.get ();
  }

  item::direction_type& item::
  direction ()
  {
    return this->direction_.get ();
  }

  void item::
  direction (const direction_type& x)
  {
    this->direction_.set (x);
  }

  void item::
  direction (::std::auto_ptr< direction_type > x)
  {
    this->direction_.set (x);
  }

  const item::behavior_type& item::
  behavior () const
  {
    return this->behavior_.get ();
  }

  item::behavior_type& item::
  behavior ()
  {
    return this->behavior_.get ();
  }

  void item::
  behavior (const behavior_type& x)
  {
    this->behavior_.set (x);
  }

  const item::type_type& item::
  type () const
  {
    return this->type_.get ();
  }

  item::type_type& item::
  type ()
  {
    return this->type_.get ();
  }

  void item::
  type (const type_type& x)
  {
    this->type_.set (x);
  }

  void item::
  type (::std::auto_ptr< type_type > x)
  {
    this->type_.set (x);
  }

  const item::extra_sequence& item::
  extra () const
  {
    return this->extra_;
  }

  item::extra_sequence& item::
  extra ()
  {
    return this->extra_;
  }

  void item::
  extra (const extra_sequence& s)
  {
    this->extra_ = s;
  }

  const item::x_type& item::
  x () const
  {
    return this->x_.get ();
  }

  item::x_type& item::
  x ()
  {
    return this->x_.get ();
  }

  void item::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const item::y_type& item::
  y () const
  {
    return this->y_.get ();
  }

  item::y_type& item::
  y ()
  {
    return this->y_.get ();
  }

  void item::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const item::z_type& item::
  z () const
  {
    return this->z_.get ();
  }

  item::z_type& item::
  z ()
  {
    return this->z_.get ();
  }

  void item::
  z (const z_type& x)
  {
    this->z_.set (x);
  }


  // axis
  // 

  axis::
  axis (value v)
  : ::xml_schema::string (_xsd_axis_literals_[v])
  {
  }

  axis::
  axis (const char* v)
  : ::xml_schema::string (v)
  {
  }

  axis::
  axis (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  axis::
  axis (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  axis::
  axis (const axis& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  axis& axis::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_axis_literals_[v]);

    return *this;
  }


  // direction
  // 

  direction::
  direction (value v)
  : ::xml_schema::string (_xsd_direction_literals_[v])
  {
  }

  direction::
  direction (const char* v)
  : ::xml_schema::string (v)
  {
  }

  direction::
  direction (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  direction::
  direction (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  direction::
  direction (const direction& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  direction& direction::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_direction_literals_[v]);

    return *this;
  }


  // type
  // 

  type::
  type (value v)
  : ::xml_schema::string (_xsd_type_literals_[v])
  {
  }

  type::
  type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  type::
  type (const type& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  type& type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_type_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace rxml
{
  // RoomXML
  //

  RoomXML::
  RoomXML (const name_type& name,
           const scenery_type& scenery,
           const xTiles_type& xTiles,
           const yTiles_type& yTiles,
           const width_type& width,
           const floorType_type& floorType,
           const floor_type& floor,
           const items_type& items)
  : ::xml_schema::type (),
    name_ (name, this),
    scenery_ (scenery, this),
    xTiles_ (xTiles, this),
    yTiles_ (yTiles, this),
    width_ (width, this),
    floorType_ (floorType, this),
    deltaX_ (this),
    deltaY_ (this),
    triple_room_data_ (this),
    floor_ (floor, this),
    walls_ (this),
    items_ (items, this)
  {
  }

  RoomXML::
  RoomXML (const name_type& name,
           const scenery_type& scenery,
           const xTiles_type& xTiles,
           const yTiles_type& yTiles,
           const width_type& width,
           const floorType_type& floorType,
           ::std::auto_ptr< floor_type > floor,
           ::std::auto_ptr< items_type > items)
  : ::xml_schema::type (),
    name_ (name, this),
    scenery_ (scenery, this),
    xTiles_ (xTiles, this),
    yTiles_ (yTiles, this),
    width_ (width, this),
    floorType_ (floorType, this),
    deltaX_ (this),
    deltaY_ (this),
    triple_room_data_ (this),
    floor_ (floor, this),
    walls_ (this),
    items_ (items, this)
  {
  }

  RoomXML::
  RoomXML (const RoomXML& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    scenery_ (x.scenery_, f, this),
    xTiles_ (x.xTiles_, f, this),
    yTiles_ (x.yTiles_, f, this),
    width_ (x.width_, f, this),
    floorType_ (x.floorType_, f, this),
    deltaX_ (x.deltaX_, f, this),
    deltaY_ (x.deltaY_, f, this),
    triple_room_data_ (x.triple_room_data_, f, this),
    floor_ (x.floor_, f, this),
    walls_ (x.walls_, f, this),
    items_ (x.items_, f, this)
  {
  }

  RoomXML::
  RoomXML (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (this),
    scenery_ (this),
    xTiles_ (this),
    yTiles_ (this),
    width_ (this),
    floorType_ (this),
    deltaX_ (this),
    deltaY_ (this),
    triple_room_data_ (this),
    floor_ (this),
    walls_ (this),
    items_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void RoomXML::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // scenery
      //
      if (n.name () == "scenery" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< scenery_type > r (
          scenery_traits::create (i, f, this));

        if (!scenery_.present ())
        {
          this->scenery_.set (r);
          continue;
        }
      }

      // xTiles
      //
      if (n.name () == "xTiles" && n.namespace_ ().empty ())
      {
        if (!xTiles_.present ())
        {
          this->xTiles_.set (xTiles_traits::create (i, f, this));
          continue;
        }
      }

      // yTiles
      //
      if (n.name () == "yTiles" && n.namespace_ ().empty ())
      {
        if (!yTiles_.present ())
        {
          this->yTiles_.set (yTiles_traits::create (i, f, this));
          continue;
        }
      }

      // width
      //
      if (n.name () == "width" && n.namespace_ ().empty ())
      {
        if (!width_.present ())
        {
          this->width_.set (width_traits::create (i, f, this));
          continue;
        }
      }

      // floorType
      //
      if (n.name () == "floorType" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< floorType_type > r (
          floorType_traits::create (i, f, this));

        if (!floorType_.present ())
        {
          this->floorType_.set (r);
          continue;
        }
      }

      // deltaX
      //
      if (n.name () == "deltaX" && n.namespace_ ().empty ())
      {
        if (!this->deltaX_)
        {
          this->deltaX_.set (deltaX_traits::create (i, f, this));
          continue;
        }
      }

      // deltaY
      //
      if (n.name () == "deltaY" && n.namespace_ ().empty ())
      {
        if (!this->deltaY_)
        {
          this->deltaY_.set (deltaY_traits::create (i, f, this));
          continue;
        }
      }

      // triple-room-data
      //
      if (n.name () == "triple-room-data" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< triple_room_data_type > r (
          triple_room_data_traits::create (i, f, this));

        if (!this->triple_room_data_)
        {
          this->triple_room_data_.set (r);
          continue;
        }
      }

      // floor
      //
      if (n.name () == "floor" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< floor_type > r (
          floor_traits::create (i, f, this));

        if (!floor_.present ())
        {
          this->floor_.set (r);
          continue;
        }
      }

      // walls
      //
      if (n.name () == "walls" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< walls_type > r (
          walls_traits::create (i, f, this));

        if (!this->walls_)
        {
          this->walls_.set (r);
          continue;
        }
      }

      // items
      //
      if (n.name () == "items" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< items_type > r (
          items_traits::create (i, f, this));

        if (!items_.present ())
        {
          this->items_.set (r);
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "");
    }

    if (!scenery_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "scenery",
        "");
    }

    if (!xTiles_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "xTiles",
        "");
    }

    if (!yTiles_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "yTiles",
        "");
    }

    if (!width_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "width",
        "");
    }

    if (!floorType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "floorType",
        "");
    }

    if (!floor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "floor",
        "");
    }

    if (!items_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "items",
        "");
    }
  }

  RoomXML* RoomXML::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class RoomXML (*this, f, c);
  }

  RoomXML& RoomXML::
  operator= (const RoomXML& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->name_ = x.name_;
      this->scenery_ = x.scenery_;
      this->xTiles_ = x.xTiles_;
      this->yTiles_ = x.yTiles_;
      this->width_ = x.width_;
      this->floorType_ = x.floorType_;
      this->deltaX_ = x.deltaX_;
      this->deltaY_ = x.deltaY_;
      this->triple_room_data_ = x.triple_room_data_;
      this->floor_ = x.floor_;
      this->walls_ = x.walls_;
      this->items_ = x.items_;
    }

    return *this;
  }

  RoomXML::
  ~RoomXML ()
  {
  }

  // floorType
  //

  floorType::
  floorType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_floorType_convert ();
  }

  floorType::
  floorType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_floorType_convert ();
  }

  floorType::
  floorType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_floorType_convert ();
  }

  floorType* floorType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class floorType (*this, f, c);
  }

  floorType::value floorType::
  _xsd_floorType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_floorType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_floorType_indexes_,
                      _xsd_floorType_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_floorType_indexes_ + 3 || _xsd_floorType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const floorType::
  _xsd_floorType_literals_[3] =
  {
    "none",
    "regular",
    "mortal"
  };

  const floorType::value floorType::
  _xsd_floorType_indexes_[3] =
  {
    ::rxml::floorType::mortal,
    ::rxml::floorType::none,
    ::rxml::floorType::regular
  };

  // triple_room_data
  //

  triple_room_data::
  triple_room_data (const bound_x_type& bound_x,
                    const bound_y_type& bound_y)
  : ::xml_schema::type (),
    northeast_ (this),
    southeast_ (this),
    northwest_ (this),
    southwest_ (this),
    eastnorth_ (this),
    eastsouth_ (this),
    westnorth_ (this),
    westsouth_ (this),
    bound_x_ (bound_x, this),
    bound_y_ (bound_y, this)
  {
  }

  triple_room_data::
  triple_room_data (::std::auto_ptr< bound_x_type > bound_x,
                    ::std::auto_ptr< bound_y_type > bound_y)
  : ::xml_schema::type (),
    northeast_ (this),
    southeast_ (this),
    northwest_ (this),
    southwest_ (this),
    eastnorth_ (this),
    eastsouth_ (this),
    westnorth_ (this),
    westsouth_ (this),
    bound_x_ (bound_x, this),
    bound_y_ (bound_y, this)
  {
  }

  triple_room_data::
  triple_room_data (const triple_room_data& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    northeast_ (x.northeast_, f, this),
    southeast_ (x.southeast_, f, this),
    northwest_ (x.northwest_, f, this),
    southwest_ (x.southwest_, f, this),
    eastnorth_ (x.eastnorth_, f, this),
    eastsouth_ (x.eastsouth_, f, this),
    westnorth_ (x.westnorth_, f, this),
    westsouth_ (x.westsouth_, f, this),
    bound_x_ (x.bound_x_, f, this),
    bound_y_ (x.bound_y_, f, this)
  {
  }

  triple_room_data::
  triple_room_data (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    northeast_ (this),
    southeast_ (this),
    northwest_ (this),
    southwest_ (this),
    eastnorth_ (this),
    eastsouth_ (this),
    westnorth_ (this),
    westsouth_ (this),
    bound_x_ (this),
    bound_y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void triple_room_data::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // northeast
      //
      if (n.name () == "northeast" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< northeast_type > r (
          northeast_traits::create (i, f, this));

        if (!this->northeast_)
        {
          this->northeast_.set (r);
          continue;
        }
      }

      // southeast
      //
      if (n.name () == "southeast" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< southeast_type > r (
          southeast_traits::create (i, f, this));

        if (!this->southeast_)
        {
          this->southeast_.set (r);
          continue;
        }
      }

      // northwest
      //
      if (n.name () == "northwest" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< northwest_type > r (
          northwest_traits::create (i, f, this));

        if (!this->northwest_)
        {
          this->northwest_.set (r);
          continue;
        }
      }

      // southwest
      //
      if (n.name () == "southwest" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< southwest_type > r (
          southwest_traits::create (i, f, this));

        if (!this->southwest_)
        {
          this->southwest_.set (r);
          continue;
        }
      }

      // eastnorth
      //
      if (n.name () == "eastnorth" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< eastnorth_type > r (
          eastnorth_traits::create (i, f, this));

        if (!this->eastnorth_)
        {
          this->eastnorth_.set (r);
          continue;
        }
      }

      // eastsouth
      //
      if (n.name () == "eastsouth" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< eastsouth_type > r (
          eastsouth_traits::create (i, f, this));

        if (!this->eastsouth_)
        {
          this->eastsouth_.set (r);
          continue;
        }
      }

      // westnorth
      //
      if (n.name () == "westnorth" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< westnorth_type > r (
          westnorth_traits::create (i, f, this));

        if (!this->westnorth_)
        {
          this->westnorth_.set (r);
          continue;
        }
      }

      // westsouth
      //
      if (n.name () == "westsouth" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< westsouth_type > r (
          westsouth_traits::create (i, f, this));

        if (!this->westsouth_)
        {
          this->westsouth_.set (r);
          continue;
        }
      }

      // bound-x
      //
      if (n.name () == "bound-x" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< bound_x_type > r (
          bound_x_traits::create (i, f, this));

        if (!bound_x_.present ())
        {
          this->bound_x_.set (r);
          continue;
        }
      }

      // bound-y
      //
      if (n.name () == "bound-y" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< bound_y_type > r (
          bound_y_traits::create (i, f, this));

        if (!bound_y_.present ())
        {
          this->bound_y_.set (r);
          continue;
        }
      }

      break;
    }

    if (!bound_x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bound-x",
        "");
    }

    if (!bound_y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bound-y",
        "");
    }
  }

  triple_room_data* triple_room_data::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class triple_room_data (*this, f, c);
  }

  triple_room_data& triple_room_data::
  operator= (const triple_room_data& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->northeast_ = x.northeast_;
      this->southeast_ = x.southeast_;
      this->northwest_ = x.northwest_;
      this->southwest_ = x.southwest_;
      this->eastnorth_ = x.eastnorth_;
      this->eastsouth_ = x.eastsouth_;
      this->westnorth_ = x.westnorth_;
      this->westsouth_ = x.westsouth_;
      this->bound_x_ = x.bound_x_;
      this->bound_y_ = x.bound_y_;
    }

    return *this;
  }

  triple_room_data::
  ~triple_room_data ()
  {
  }

  // floor
  //

  floor::
  floor ()
  : ::xml_schema::type (),
    tile_ (this)
  {
  }

  floor::
  floor (const floor& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    tile_ (x.tile_, f, this)
  {
  }

  floor::
  floor (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    tile_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void floor::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // tile
      //
      if (n.name () == "tile" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< tile_type > r (
          tile_traits::create (i, f, this));

        this->tile_.push_back (r);
        continue;
      }

      break;
    }
  }

  floor* floor::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class floor (*this, f, c);
  }

  floor& floor::
  operator= (const floor& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->tile_ = x.tile_;
    }

    return *this;
  }

  floor::
  ~floor ()
  {
  }

  // walls
  //

  walls::
  walls ()
  : ::xml_schema::type (),
    wall_ (this)
  {
  }

  walls::
  walls (const walls& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    wall_ (x.wall_, f, this)
  {
  }

  walls::
  walls (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    wall_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void walls::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // wall
      //
      if (n.name () == "wall" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< wall_type > r (
          wall_traits::create (i, f, this));

        this->wall_.push_back (r);
        continue;
      }

      break;
    }
  }

  walls* walls::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class walls (*this, f, c);
  }

  walls& walls::
  operator= (const walls& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->wall_ = x.wall_;
    }

    return *this;
  }

  walls::
  ~walls ()
  {
  }

  // items
  //

  items::
  items ()
  : ::xml_schema::type (),
    item_ (this)
  {
  }

  items::
  items (const items& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    item_ (x.item_, f, this)
  {
  }

  items::
  items (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    item_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void items::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // item
      //
      if (n.name () == "item" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< item_type > r (
          item_traits::create (i, f, this));

        this->item_.push_back (r);
        continue;
      }

      break;
    }
  }

  items* items::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class items (*this, f, c);
  }

  items& items::
  operator= (const items& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->item_ = x.item_;
    }

    return *this;
  }

  items::
  ~items ()
  {
  }

  // northeast
  //

  northeast::
  northeast (const x_type& x,
             const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  northeast::
  northeast (const northeast& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  northeast::
  northeast (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void northeast::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  northeast* northeast::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class northeast (*this, f, c);
  }

  northeast& northeast::
  operator= (const northeast& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  northeast::
  ~northeast ()
  {
  }

  // southeast
  //

  southeast::
  southeast (const x_type& x,
             const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  southeast::
  southeast (const southeast& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  southeast::
  southeast (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void southeast::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  southeast* southeast::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class southeast (*this, f, c);
  }

  southeast& southeast::
  operator= (const southeast& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  southeast::
  ~southeast ()
  {
  }

  // northwest
  //

  northwest::
  northwest (const x_type& x,
             const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  northwest::
  northwest (const northwest& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  northwest::
  northwest (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void northwest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  northwest* northwest::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class northwest (*this, f, c);
  }

  northwest& northwest::
  operator= (const northwest& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  northwest::
  ~northwest ()
  {
  }

  // southwest
  //

  southwest::
  southwest (const x_type& x,
             const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  southwest::
  southwest (const southwest& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  southwest::
  southwest (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void southwest::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  southwest* southwest::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class southwest (*this, f, c);
  }

  southwest& southwest::
  operator= (const southwest& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  southwest::
  ~southwest ()
  {
  }

  // eastnorth
  //

  eastnorth::
  eastnorth (const x_type& x,
             const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  eastnorth::
  eastnorth (const eastnorth& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  eastnorth::
  eastnorth (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void eastnorth::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  eastnorth* eastnorth::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class eastnorth (*this, f, c);
  }

  eastnorth& eastnorth::
  operator= (const eastnorth& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  eastnorth::
  ~eastnorth ()
  {
  }

  // eastsouth
  //

  eastsouth::
  eastsouth (const x_type& x,
             const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  eastsouth::
  eastsouth (const eastsouth& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  eastsouth::
  eastsouth (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void eastsouth::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  eastsouth* eastsouth::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class eastsouth (*this, f, c);
  }

  eastsouth& eastsouth::
  operator= (const eastsouth& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  eastsouth::
  ~eastsouth ()
  {
  }

  // westnorth
  //

  westnorth::
  westnorth (const x_type& x,
             const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  westnorth::
  westnorth (const westnorth& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  westnorth::
  westnorth (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void westnorth::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  westnorth* westnorth::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class westnorth (*this, f, c);
  }

  westnorth& westnorth::
  operator= (const westnorth& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  westnorth::
  ~westnorth ()
  {
  }

  // westsouth
  //

  westsouth::
  westsouth (const x_type& x,
             const y_type& y)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this)
  {
  }

  westsouth::
  westsouth (const westsouth& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this)
  {
  }

  westsouth::
  westsouth (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void westsouth::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }
  }

  westsouth* westsouth::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class westsouth (*this, f, c);
  }

  westsouth& westsouth::
  operator= (const westsouth& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
    }

    return *this;
  }

  westsouth::
  ~westsouth ()
  {
  }

  // bound_x
  //

  bound_x::
  bound_x (const minimum_type& minimum,
           const maximum_type& maximum)
  : ::xml_schema::type (),
    minimum_ (minimum, this),
    maximum_ (maximum, this)
  {
  }

  bound_x::
  bound_x (const bound_x& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    minimum_ (x.minimum_, f, this),
    maximum_ (x.maximum_, f, this)
  {
  }

  bound_x::
  bound_x (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    minimum_ (this),
    maximum_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void bound_x::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // minimum
      //
      if (n.name () == "minimum" && n.namespace_ ().empty ())
      {
        if (!minimum_.present ())
        {
          this->minimum_.set (minimum_traits::create (i, f, this));
          continue;
        }
      }

      // maximum
      //
      if (n.name () == "maximum" && n.namespace_ ().empty ())
      {
        if (!maximum_.present ())
        {
          this->maximum_.set (maximum_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!minimum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "minimum",
        "");
    }

    if (!maximum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "maximum",
        "");
    }
  }

  bound_x* bound_x::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bound_x (*this, f, c);
  }

  bound_x& bound_x::
  operator= (const bound_x& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->minimum_ = x.minimum_;
      this->maximum_ = x.maximum_;
    }

    return *this;
  }

  bound_x::
  ~bound_x ()
  {
  }

  // bound_y
  //

  bound_y::
  bound_y (const minimum_type& minimum,
           const maximum_type& maximum)
  : ::xml_schema::type (),
    minimum_ (minimum, this),
    maximum_ (maximum, this)
  {
  }

  bound_y::
  bound_y (const bound_y& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    minimum_ (x.minimum_, f, this),
    maximum_ (x.maximum_, f, this)
  {
  }

  bound_y::
  bound_y (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    minimum_ (this),
    maximum_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void bound_y::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // minimum
      //
      if (n.name () == "minimum" && n.namespace_ ().empty ())
      {
        if (!minimum_.present ())
        {
          this->minimum_.set (minimum_traits::create (i, f, this));
          continue;
        }
      }

      // maximum
      //
      if (n.name () == "maximum" && n.namespace_ ().empty ())
      {
        if (!maximum_.present ())
        {
          this->maximum_.set (maximum_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!minimum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "minimum",
        "");
    }

    if (!maximum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "maximum",
        "");
    }
  }

  bound_y* bound_y::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class bound_y (*this, f, c);
  }

  bound_y& bound_y::
  operator= (const bound_y& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->minimum_ = x.minimum_;
      this->maximum_ = x.maximum_;
    }

    return *this;
  }

  bound_y::
  ~bound_y ()
  {
  }

  // tile
  //

  tile::
  tile (const x_type& x,
        const y_type& y,
        const offsetX_type& offsetX,
        const offsetY_type& offsetY,
        const bitmap_type& bitmap)
  : ::xml_schema::type (),
    x_ (x, this),
    y_ (y, this),
    offsetX_ (offsetX, this),
    offsetY_ (offsetY, this),
    bitmap_ (bitmap, this)
  {
  }

  tile::
  tile (const tile& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    offsetX_ (x.offsetX_, f, this),
    offsetY_ (x.offsetY_, f, this),
    bitmap_ (x.bitmap_, f, this)
  {
  }

  tile::
  tile (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (this),
    y_ (this),
    offsetX_ (this),
    offsetY_ (this),
    bitmap_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void tile::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      // offsetX
      //
      if (n.name () == "offsetX" && n.namespace_ ().empty ())
      {
        if (!offsetX_.present ())
        {
          this->offsetX_.set (offsetX_traits::create (i, f, this));
          continue;
        }
      }

      // offsetY
      //
      if (n.name () == "offsetY" && n.namespace_ ().empty ())
      {
        if (!offsetY_.present ())
        {
          this->offsetY_.set (offsetY_traits::create (i, f, this));
          continue;
        }
      }

      // bitmap
      //
      if (n.name () == "bitmap" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< bitmap_type > r (
          bitmap_traits::create (i, f, this));

        if (!bitmap_.present ())
        {
          this->bitmap_.set (r);
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "");
    }

    if (!offsetX_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "offsetX",
        "");
    }

    if (!offsetY_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "offsetY",
        "");
    }

    if (!bitmap_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bitmap",
        "");
    }
  }

  tile* tile::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class tile (*this, f, c);
  }

  tile& tile::
  operator= (const tile& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->x_ = x.x_;
      this->y_ = x.y_;
      this->offsetX_ = x.offsetX_;
      this->offsetY_ = x.offsetY_;
      this->bitmap_ = x.bitmap_;
    }

    return *this;
  }

  tile::
  ~tile ()
  {
  }

  // wall
  //

  wall::
  wall (const axis_type& axis,
        const index_type& index,
        const bitmap_type& bitmap)
  : ::xml_schema::type (),
    axis_ (axis, this),
    index_ (index, this),
    bitmap_ (bitmap, this)
  {
  }

  wall::
  wall (const wall& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    axis_ (x.axis_, f, this),
    index_ (x.index_, f, this),
    bitmap_ (x.bitmap_, f, this)
  {
  }

  wall::
  wall (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    axis_ (this),
    index_ (this),
    bitmap_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void wall::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // axis
      //
      if (n.name () == "axis" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< axis_type > r (
          axis_traits::create (i, f, this));

        if (!axis_.present ())
        {
          this->axis_.set (r);
          continue;
        }
      }

      // index
      //
      if (n.name () == "index" && n.namespace_ ().empty ())
      {
        if (!index_.present ())
        {
          this->index_.set (index_traits::create (i, f, this));
          continue;
        }
      }

      // bitmap
      //
      if (n.name () == "bitmap" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< bitmap_type > r (
          bitmap_traits::create (i, f, this));

        if (!bitmap_.present ())
        {
          this->bitmap_.set (r);
          continue;
        }
      }

      break;
    }

    if (!axis_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "axis",
        "");
    }

    if (!index_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "index",
        "");
    }

    if (!bitmap_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bitmap",
        "");
    }
  }

  wall* wall::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class wall (*this, f, c);
  }

  wall& wall::
  operator= (const wall& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->axis_ = x.axis_;
      this->index_ = x.index_;
      this->bitmap_ = x.bitmap_;
    }

    return *this;
  }

  wall::
  ~wall ()
  {
  }

  // item
  //

  item::
  item (const label_type& label,
        const direction_type& direction,
        const behavior_type& behavior,
        const type_type& type,
        const x_type& x,
        const y_type& y,
        const z_type& z)
  : ::xml_schema::type (),
    label_ (label, this),
    direction_ (direction, this),
    behavior_ (behavior, this),
    type_ (type, this),
    extra_ (this),
    x_ (x, this),
    y_ (y, this),
    z_ (z, this)
  {
  }

  item::
  item (const item& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    label_ (x.label_, f, this),
    direction_ (x.direction_, f, this),
    behavior_ (x.behavior_, f, this),
    type_ (x.type_, f, this),
    extra_ (x.extra_, f, this),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  item::
  item (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    label_ (this),
    direction_ (this),
    behavior_ (this),
    type_ (this),
    extra_ (this),
    x_ (this),
    y_ (this),
    z_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void item::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // label
      //
      if (n.name () == "label" && n.namespace_ ().empty ())
      {
        if (!label_.present ())
        {
          this->label_.set (label_traits::create (i, f, this));
          continue;
        }
      }

      // direction
      //
      if (n.name () == "direction" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< direction_type > r (
          direction_traits::create (i, f, this));

        if (!direction_.present ())
        {
          this->direction_.set (r);
          continue;
        }
      }

      // behavior
      //
      if (n.name () == "behavior" && n.namespace_ ().empty ())
      {
        if (!behavior_.present ())
        {
          this->behavior_.set (behavior_traits::create (i, f, this));
          continue;
        }
      }

      // type
      //
      if (n.name () == "type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< type_type > r (
          type_traits::create (i, f, this));

        if (!type_.present ())
        {
          this->type_.set (r);
          continue;
        }
      }

      // extra
      //
      if (n.name () == "extra" && n.namespace_ ().empty ())
      {
        this->extra_.push_back (extra_traits::create (i, f, this));
        continue;
      }

      break;
    }

    if (!label_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "label",
        "");
    }

    if (!direction_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "direction",
        "");
    }

    if (!behavior_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "behavior",
        "");
    }

    if (!type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "type",
        "");
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "x" && n.namespace_ ().empty ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "y" && n.namespace_ ().empty ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }

      if (n.name () == "z" && n.namespace_ ().empty ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "x",
        "");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "y",
        "");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "z",
        "");
    }
  }

  item* item::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class item (*this, f, c);
  }

  item& item::
  operator= (const item& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::type& > (*this) = x;
      this->label_ = x.label_;
      this->direction_ = x.direction_;
      this->behavior_ = x.behavior_;
      this->type_ = x.type_;
      this->extra_ = x.extra_;
      this->x_ = x.x_;
      this->y_ = x.y_;
      this->z_ = x.z_;
    }

    return *this;
  }

  item::
  ~item ()
  {
  }

  // axis
  //

  axis::
  axis (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_axis_convert ();
  }

  axis::
  axis (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_axis_convert ();
  }

  axis::
  axis (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_axis_convert ();
  }

  axis* axis::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class axis (*this, f, c);
  }

  axis::value axis::
  _xsd_axis_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_axis_literals_);
    const value* i (::std::lower_bound (
                      _xsd_axis_indexes_,
                      _xsd_axis_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_axis_indexes_ + 2 || _xsd_axis_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const axis::
  _xsd_axis_literals_[2] =
  {
    "x",
    "y"
  };

  const axis::value axis::
  _xsd_axis_indexes_[2] =
  {
    ::rxml::axis::x,
    ::rxml::axis::y
  };

  // direction
  //

  direction::
  direction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_direction_convert ();
  }

  direction::
  direction (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_direction_convert ();
  }

  direction::
  direction (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_direction_convert ();
  }

  direction* direction::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class direction (*this, f, c);
  }

  direction::value direction::
  _xsd_direction_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_direction_literals_);
    const value* i (::std::lower_bound (
                      _xsd_direction_indexes_,
                      _xsd_direction_indexes_ + 13,
                      *this,
                      c));

    if (i == _xsd_direction_indexes_ + 13 || _xsd_direction_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const direction::
  _xsd_direction_literals_[13] =
  {
    "none",
    "south",
    "west",
    "north",
    "east",
    "northeast",
    "southeast",
    "southwest",
    "northwest",
    "eastnorth",
    "eastsouth",
    "westnorth",
    "westsouth"
  };

  const direction::value direction::
  _xsd_direction_indexes_[13] =
  {
    ::rxml::direction::east,
    ::rxml::direction::eastnorth,
    ::rxml::direction::eastsouth,
    ::rxml::direction::none,
    ::rxml::direction::north,
    ::rxml::direction::northeast,
    ::rxml::direction::northwest,
    ::rxml::direction::south,
    ::rxml::direction::southeast,
    ::rxml::direction::southwest,
    ::rxml::direction::west,
    ::rxml::direction::westnorth,
    ::rxml::direction::westsouth
  };

  // type
  //

  type::
  type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_type_convert ();
  }

  type::
  type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_type_convert ();
  }

  type* type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class type (*this, f, c);
  }

  type::value type::
  _xsd_type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_type_indexes_,
                      _xsd_type_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_type_indexes_ + 4 || _xsd_type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const type::
  _xsd_type_literals_[4] =
  {
    "wall",
    "door",
    "griditem",
    "freeitem"
  };

  const type::value type::
  _xsd_type_indexes_[4] =
  {
    ::rxml::type::door,
    ::rxml::type::freeitem,
    ::rxml::type::griditem,
    ::rxml::type::wall
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace rxml
{
  ::std::auto_ptr< ::rxml::RoomXML >
  room (const ::std::string& u,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::rxml::RoomXML > (
      ::rxml::room (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (const ::std::string& u,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::rxml::RoomXML > (
      ::rxml::room (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (const ::std::string& u,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::rxml::RoomXML > (
      ::rxml::room (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::std::istream& is,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::rxml::room (isrc, f, p);
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::std::istream& is,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::rxml::room (isrc, h, f, p);
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::std::istream& is,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::rxml::room (isrc, h, f, p);
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::rxml::room (isrc, f, p);
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::std::istream& is,
        const ::std::string& sid,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::rxml::room (isrc, h, f, p);
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::std::istream& is,
        const ::std::string& sid,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::rxml::room (isrc, h, f, p);
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::xercesc::InputSource& i,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::auto_ptr< ::rxml::RoomXML > (
      ::rxml::room (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::xercesc::InputSource& i,
        ::xml_schema::error_handler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::rxml::RoomXML > (
      ::rxml::room (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::xercesc::InputSource& i,
        ::xercesc::DOMErrorHandler& h,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::auto_ptr< ::rxml::RoomXML > (
      ::rxml::room (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (const ::xercesc::DOMDocument& doc,
        ::xml_schema::flags f,
        const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::auto_ptr< ::rxml::RoomXML > (
        ::rxml::room (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "room" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::rxml::RoomXML > r (
        ::xsd::cxx::tree::traits< ::rxml::RoomXML, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "room",
      "");
  }

  ::std::auto_ptr< ::rxml::RoomXML >
  room (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
        ::xml_schema::flags f,
        const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "room" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::rxml::RoomXML > r (
        ::xsd::cxx::tree::traits< ::rxml::RoomXML, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "room",
      "");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace rxml
{
  void
  room (::std::ostream& o,
        const ::rxml::RoomXML& s,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::rxml::room (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  room (::std::ostream& o,
        const ::rxml::RoomXML& s,
        ::xml_schema::error_handler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::rxml::room (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  room (::std::ostream& o,
        const ::rxml::RoomXML& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::rxml::room (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  room (::xercesc::XMLFormatTarget& t,
        const ::rxml::RoomXML& s,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::rxml::room (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  room (::xercesc::XMLFormatTarget& t,
        const ::rxml::RoomXML& s,
        ::xml_schema::error_handler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::rxml::room (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  room (::xercesc::XMLFormatTarget& t,
        const ::rxml::RoomXML& s,
        ::xercesc::DOMErrorHandler& h,
        const ::xml_schema::namespace_infomap& m,
        const ::std::string& e,
        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::rxml::room (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  room (::xercesc::DOMDocument& d,
        const ::rxml::RoomXML& s,
        ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "room" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "room",
        "");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  room (const ::rxml::RoomXML& s,
        const ::xml_schema::namespace_infomap& m,
        ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "room",
        "",
        m, f));

    ::rxml::room (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const RoomXML& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          e));

      s << i.name ();
    }

    // scenery
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scenery",
          e));

      s << i.scenery ();
    }

    // xTiles
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "xTiles",
          e));

      s << i.xTiles ();
    }

    // yTiles
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "yTiles",
          e));

      s << i.yTiles ();
    }

    // width
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "width",
          e));

      s << i.width ();
    }

    // floorType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "floorType",
          e));

      s << i.floorType ();
    }

    // deltaX
    //
    if (i.deltaX ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deltaX",
          e));

      s << *i.deltaX ();
    }

    // deltaY
    //
    if (i.deltaY ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "deltaY",
          e));

      s << *i.deltaY ();
    }

    // triple-room-data
    //
    if (i.triple_room_data ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "triple-room-data",
          e));

      s << *i.triple_room_data ();
    }

    // floor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "floor",
          e));

      s << i.floor ();
    }

    // walls
    //
    if (i.walls ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "walls",
          e));

      s << *i.walls ();
    }

    // items
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "items",
          e));

      s << i.items ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const floorType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const floorType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const floorType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const triple_room_data& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // northeast
    //
    if (i.northeast ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "northeast",
          e));

      s << *i.northeast ();
    }

    // southeast
    //
    if (i.southeast ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "southeast",
          e));

      s << *i.southeast ();
    }

    // northwest
    //
    if (i.northwest ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "northwest",
          e));

      s << *i.northwest ();
    }

    // southwest
    //
    if (i.southwest ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "southwest",
          e));

      s << *i.southwest ();
    }

    // eastnorth
    //
    if (i.eastnorth ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "eastnorth",
          e));

      s << *i.eastnorth ();
    }

    // eastsouth
    //
    if (i.eastsouth ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "eastsouth",
          e));

      s << *i.eastsouth ();
    }

    // westnorth
    //
    if (i.westnorth ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "westnorth",
          e));

      s << *i.westnorth ();
    }

    // westsouth
    //
    if (i.westsouth ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "westsouth",
          e));

      s << *i.westsouth ();
    }

    // bound-x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bound-x",
          e));

      s << i.bound_x ();
    }

    // bound-y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bound-y",
          e));

      s << i.bound_y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const floor& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // tile
    //
    for (floor::tile_const_iterator
         b (i.tile ().begin ()), n (i.tile ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "tile",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const walls& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // wall
    //
    for (walls::wall_const_iterator
         b (i.wall ().begin ()), n (i.wall ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "wall",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const items& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // item
    //
    for (items::item_const_iterator
         b (i.item ().begin ()), n (i.item ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "item",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const northeast& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const southeast& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const northwest& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const southwest& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const eastnorth& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const eastsouth& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const westnorth& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const westsouth& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const bound_x& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // minimum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "minimum",
          e));

      s << i.minimum ();
    }

    // maximum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maximum",
          e));

      s << i.maximum ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const bound_y& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // minimum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "minimum",
          e));

      s << i.minimum ();
    }

    // maximum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maximum",
          e));

      s << i.maximum ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const tile& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          e));

      s << i.y ();
    }

    // offsetX
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "offsetX",
          e));

      s << i.offsetX ();
    }

    // offsetY
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "offsetY",
          e));

      s << i.offsetY ();
    }

    // bitmap
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bitmap",
          e));

      s << i.bitmap ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const wall& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // axis
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "axis",
          e));

      s << i.axis ();
    }

    // index
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "index",
          e));

      s << i.index ();
    }

    // bitmap
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "bitmap",
          e));

      s << i.bitmap ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const item& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // label
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "label",
          e));

      s << i.label ();
    }

    // direction
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "direction",
          e));

      s << i.direction ();
    }

    // behavior
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "behavior",
          e));

      s << i.behavior ();
    }

    // type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "type",
          e));

      s << i.type ();
    }

    // extra
    //
    for (item::extra_const_iterator
         b (i.extra ().begin ()), n (i.extra ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "extra",
          e));

      s << *b;
    }

    // x
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "x",
          e));

      a << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "y",
          e));

      a << i.y ();
    }

    // z
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "z",
          e));

      a << i.z ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const axis& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const axis& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const axis& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const direction& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const direction& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const direction& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const type& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const type& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const type& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

